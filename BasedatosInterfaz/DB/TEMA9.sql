--TABLA FAMILIAS
CREATE TABLE FAMILIAS(
    cCodFam VARCHAR2(13) NOT NULL,   --CODIGO
    cDesFam VARCHAR2(100) NOT NULL,  --DESCRIPCION
    CONSTRAINT PK_FAMILIAS PRIMARY KEY (cCodFam)
);
--TABLA ARTICULOS
CREATE TABLE ARTICULOS(
    cCodArt VARCHAR2(13) NOT NULL,   --CODIGO ARTICULO
    cCodFam VARCHAR2(13) NOT NULL,  --CODIGO FAMILIA
    cDesArt VARCHAR2(100) NOT NULL,  --DESCRIPCION ARTICULO
    nPvpArt NUMBER(10,3) NOT NULL,   --PRECIO
    nStockArt NUMBER(10,3) NOT NULL,   --STOCK
    nStockMinArt NUMBER(10,3) NOT NULL, --STOCK MINIMO
    nDtoArt NUMBER(10,3) NOT NULL,       --DESCUENTO
    CONSTRAINT PK_ARTICULOS PRIMARY KEY(cCodaRT)
);

CREATE TABLE CLIENTES(
    cCodCli VARCHAR2(13) NOT NULL,   --CODIGO CLIENTE
    cNomCli VARCHAR2(100) NOT NULL,  --NOMBRE
    nDtoCli NUMBER(10,3) NOT NULL,  --DESCUENTO CLIENTE
    nDia1Pago NUMBER(2) NOT NULL,   --DIA 1 DE PAGO
    nDia2Pago NUMBER(2) NOT NULL,   --DIA 2 DE PAGO
    CONSTRAINT PK_CLIENTES PRIMARY KEY(cCodCli)
);

CREATE TABLE FACTURAS(
    nNumFac NUMBER(10) NOT NULL,  --DESCUENTO CLIENTE
    cCodCli VARCHAR2(13) NOT NULL,   --CODIGO CLIENTE
    dFecFac DATE,  --NOMBRE
    nDtoFac NUMBER(10,3) NOT NULL,  --DESCUENTO CLIENTE
    nIvaFac NUMBER(10,3) NOT NULL,  --DIA 1 DE PAGO
    nBaseImo NUMBER(10,3) NOT NULL,  --DIA 2 DE PAGO
    nTotFac NUMBER(10,3) NOT NULL,
    CONSTRAINT PK_facturas PRIMARY KEY(nNumFac)
);
ALTER TABLE FACTURAS ADD CONSTRAINT FK_FACTURAS_CLIENTES
FOREIGN KEY (cCodCli) REFERENCES CLIENTES (cCodCli);

ALTER TABLE ARTICULOS ADD CONSTRAINT FK_ARTICULOS_FAMILIAS
FOREIGN KEY (cCodFam) REFERENCES FAMILIAS (cCodFam);

CREATE TABLE LINEASFACTURAS(
    nNumFac NUMBER(10) NOT NULL,  --DESCUENTO CLIENTE
    nNumLin NUMBER(10) NOT NULL,    --CODIGO CLIENTE
    cCodArt VARCHAR2(13),
    nCanArtc NUMBER(10,3) NOT NULL,  --DESCUENTO CLIENTE
    nDtoLinFac NUMBER(10,3) NOT NULL,  --DIA 1 DE PAGO

    CONSTRAINT PK_LINEAFACTURAS PRIMARY KEY(nNumFac,nNumLin)
);

ALTER TABLE LINEASFACTURAS  ADD CONSTRAINT FK_LINEASFACTURAS_FACTURAS
FOREIGN KEY (nNumFac) REFERENCES FACTURAS  (nNumFac);


INSERT INTO FAMILIAS VALUES ('SE','SEAT');
INSERT INTO FAMILIAS VALUES ('VW','VOLSWAGEN');
INSERT INTO FAMILIAS VALUES ('OP','OPEL');
INSERT INTO FAMILIAS VALUES ('AU','AUDI');

INSERT INTO ARTICULOS VALUES ('SE01','SE','SEAT PANDA',1000,2,0,30);
INSERT INTO ARTICULOS VALUES ('SE02','SE','SEAT LEON',11000,3,0,10);
INSERT INTO ARTICULOS VALUES ('SE03','SE','SEAT IBIZA',9990,2,0,30);

INSERT INTO ARTICULOS VALUES ('VW01','VW','POLO',9990,2,0,30);
INSERT INTO ARTICULOS VALUES ('VW02','VW','PASSAT',14000,3,1,10);
INSERT INTO ARTICULOS VALUES ('VW03','VW','SCIROCCO',19990,2,0,25);

/* PROCEDIMIENTO ALMAENADO QUE PIDE POR TECLADO EL CODIGO DE UNA FAMILIA/MARCA
Y NOS MUESTRE POR PANTALLA UNA LISTA DE LOS ARTICULOS/COCHES DE ESA FAMILIA/MARCA.*/

SET SERVEROUTPUT ON;
DECLARE
    cCodMarca FAMILIAS.ccodFam%type;
    cursor coches (xCod FAMILIAS.ccodFam%type) is select * from articulos where cCodFam=xCod;
    resultado coches%rowtype;
BEGIN
    cCodMarCa := &Introduce_cod_marca;
    OPEN coches(cCodMarca);
    LOOP 
        FETCH coches INTO resultado;
        EXIT WHEN coches%NOTFOUND;
        dbms_output.put_line(resultado.cCodArt || resultado.cDesArt);
    END LOOP;
    CLOSE coches;
END;
select * from familias;

/*VERSION 2.0
PROCEDIMIENTO ALMACENADO QUE NOS MUESTRE POR PANTALLA UNA LISTA DE LOS ARTICULOS/COCHES
DE CADA FAMILIA/MARCA*/

SET SERVEROUTPUT ON;
DECLARE
    cCodMarca FAMILIAS.ccodFam%type;
    cursor cMarcas (xDes FAMILIAS.cDesFam%type)is select * from articulos where CDESFAM = xDes;
    cursor coches (xCod FAMILIAS.ccodFam%type) is select * from articulos where cCodFam = xCod;
    variables coches%rowtype;
    v_cMarcas FAMILIAS%rowtype;
    
BEGIN  
    OPEN cMARCAS;
    LOOP
        FETCH cMarcas INTO v_cMarcas;
        EXIT WHEN cMarcas%NOTFOUND;
        dbms_output.put_line('MARCA: ' || variables.cCodArt || variables.cDesArt);
    END LOOP;
    OPEN coches(cCodMarca);
    LOOP 
        FETCH coches INTO variables;
        EXIT WHEN coches%NOTFOUND;
        dbms_output.put_line(variables.cCodArt || variables.cDesArt);
    END LOOP;
    CLOSE coches;
END;


/*VERSION 3.0
Y QUE ADEMAS NOS DIGA CUANTOS COCHES HAY DE CADA MARCA*/


SET SERVEROUTPUT ON;
DECLARE
    CURSOR cMarcas IS 
        SELECT * FROM FAMILIAS;
    v_cMarcas FAMILIAS%ROWTYPE; 
    CURSOR cCoches(xCod familias.ccodfam%type) IS
        SELECT * FROM articulos WHERE cCodFam = xCod;
    v_cCoches ARTICULOS%ROWTYPE;   
    nNumCoches NUMBER;
BEGIN
    OPEN cMarcas;
    LOOP
        FETCH cMarcas INTO v_cMarcas;
        EXIT WHEN cMarcas%NOTFOUND;
        dbms_output.put_line('MARCA: '|| v_cMarcas.cCodFam || '-' ||  v_cMarcas.CDESFAM);
        nNumCoches := 0;
    END LOOP;
    CLOSE cMarcas;
    OPEN cCoches(v_cMarcas.cCodFam);
    LOOP    
        FETCH cCoches INTO v_cCoches;
        EXIT WHEN cCoches%NOTFOUND;
        dbms_output.put_line('Modelo: ' || nNumCoches || '-' || v_coCches.CCODFAM);   
    END LOOP;
    CLOSE cCoches;
END;
    
    
  --CLIENTES
  
  
  
    
SET SERVEROUTPUT ON;
DECLARE
 
    cursor coches is 
    select * from articulos;
    resultado coches%rowtype;
BEGIN
  
    OPEN coches;
    LOOP 
        FETCH coches INTO resultado;
        EXIT WHEN coches%NOTFOUND;
        dbms_output.put_line(resultado.cCodArt);
    END LOOP;
    CLOSE coches;
END;

select * from CLIENTES;




INSERT INTO CLIENTES VALUES( 
'A2','MANOLO',23,3,4);

SET SERVEROUTPUT ON;
DECLARE

    CURSOR CLIENTES IS 
    SELECT * FROM CLIENTES;
    VARIABLE CLIENTES%ROWTYPE;
BEGIN
    OPEN CLIENTES;
    LOOP
        FETCH CLIENTES INTO VARIABLE;
        EXIT WHEN CLIENTES%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('NOBBRE CLIENTE: ' ||VARIABLE.CNOMCLI || ' DIA DE PAGO 1: ' || VARIABLE.NDIA1PAGO);
    END LOOP;
    CLOSE CLIENTES;
END;

SET SERVEROUTPUT ON;
DECLARE
    CURSOR ARTICULOS IS
    SELECT * FROM ARTICULOS;
    VARIABLE ARTICULOS%ROWTYPE;
BEGIN
    OPEN ARTICULOS;
    LOOP 
        FETCH ARTICULOS INTO VARIABLE;
        EXIT WHEN ARTICULOS%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE('ARTICULO ' || ARTICULOS.CCODART);
    END LOOP;
    CLOSE ARTICULOS;
END;



-------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE sp_hola 
IS
BEGIN
DBMS_OUTPUT.PUT_LINE( 'HOLA ');
END;
    
SET SERVEROUTPUT ON;
BEGIN
    SP_HOLA;
END;
    
CREATE OR REPLACE PROCEDURE SP_TABALMULTI (NUMERO NUMBER)
IS
BEGIN
    FOR I IN 1..10 LOOP
        DBMS_OUTPUT.PUT_LINE ( I * NUMERO);
    END LOOP;
END;

SET SERVEROUTPUT ON;
BEGIN
    SP_TABALMULTI(3);
END;   

--PUEDE TENER LOS PARAMETROS DE SALIDA QUE QUERAMOS
CREATE OR REPLACE PROCEDURE SP_TABALMULTI2 (NUMERO NUMBER, HASTA NUMBER)
IS
BEGIN
    FOR I IN 1..HASTA LOOP
        DBMS_OUTPUT.PUT_LINE ( I * NUMERO);
    END LOOP;
END;

SET SERVEROUTPUT ON;
BEGIN
    SP_TABALMULTI2(3,25);
END; 

CREATE OR REPLACE PROCEDURE SP_TABALMULTI3 (NUMERO NUMBER, HASTA NUMBER, RESU OUT NUMBER)
IS
BEGIN
    RESU := 0;
    FOR I IN 1..HASTA LOOP
        DBMS_OUTPUT.PUT_LINE ( I * NUMERO);
        RESU := RESU + (I* NUMERO);
    END LOOP;
END;

SET SERVEROUTPUT ON;
DECLARE
    X NUMBER;
BEGIN
    SP_TABALMULTI3(5,4,X);
    DBMS_OUTPUT.PUT_LINE (' X = ' || X);
END;


CREATE OR REPLACE PROCEDURE SP_TABALMULTI4 (NUMERO NUMBER, HASTA NUMBER, RESU OUT NUMBER, RESU2 OUT NUMBER)
IS
BEGIN
    RESU := 0;
    FOR I IN 1..HASTA LOOP
        DBMS_OUTPUT.PUT_LINE ( I * NUMERO);
        RESU := RESU + (I* NUMERO);
    END LOOP;
    RESU2 := RESU * RESU;
END;

SET SERVEROUTPUT ON;
DECLARE
    X NUMBER;
    W NUMBER;
BEGIN
    SP_TABALMULTI4(5,4,X,W);
    DBMS_OUTPUT.PUT_LINE (' X = ' || X || ' Y SU CUADRADO ES: ' || W);
END;

CREATE OR REPLACE PROCEDURE SP_TABALMULTI4 (NUMERO NUMBER, HASTA NUMBER, RESU OUT NUMBER, RESU2 OUT NUMBER)
IS
    varlocal VARCHAR2(10);
BEGIN
    RESU := 0;
    RESU2 :=0;
    FOR I IN 1..HASTA LOOP
        DBMS_OUTPUT.PUT_LINE ( I * NUMERO);
        RESU := RESU + (I* NUMERO);
    END LOOP;
    RESU2 := RESU * RESU;
END;


create or replace
PROCEDURE sp_NumFacxCli (xcCodCli facturas.CCODCLI%TYPE, xnNumFac OUT NUMBER )
IS
BEGIN
    SELECT COUNT(*) INTO xnNumFac FROM FACTURAS WHERE cCodCli = xcCodCli;
END;


SET SERVEROUTPUT ON;
DECLARE
    Xnf NUMBER;
    xc facturas.ccodcli%TYPE; --de esta forma le pasas el parametro por variable
BEGIN
    sp_NumFacxCli(xc,xnf);
     DBMS_OUTPUT.PUT_LINE ('El cliente 25 tiene ' || xnf || ' facturas.');
END;

SELECT * FROM CLIENTES;
--INTRODUCIR INFORMACIÓN EN LAS TABLAS
INSERT INTO CLIENTES VALUES('A4','PEDRO', 0,10,0);
INSERT INTO CLIENTES VALUES('A3','FERNANDO', 0,0,0);
INSERT INTO CLIENTES VALUES('A5','FEDERICO', 10,5,4);

INSERT INTO FACTURAS VALUES(1,'A1','01/03/2017',5,4,32,145);
INSERT INTO FACTURAS VALUES(2,'A1','05/04/2017',5,4,56,230);
INSERT INTO FACTURAS VALUES(3,'A3','01/06/2017',5,4,32,145);
INSERT INTO FACTURAS VALUES(4,'A2','05/02/2018',5,4,32,145);
INSERT INTO FACTURAS VALUES(5,'A2','09/03/2017',5,4,36,167);
INSERT INTO FACTURAS VALUES(6,'A3','01/07/2017',5,4,32,145);

INSERT INTO LINEASFACTURAS VALUES(1,'A1','SE01',5,4);
SELECT * FROM ARTICULOS;
--CREAR UN PROCEDIMIENTO QUE NOS DE COMO PARAMETRO DE SALIDA CUANTAS LINEAS DE FACTURAS SE HAN REALIZADO
--DE UN CODIGO DE FAMILIA ENTRE DOS FECHAS DE FACTURAS
CREATE OR REPLACE PROCEDURE sp_LinFacxFan (xcCodFam FAMILIAS.cCodFam%TYPE, dFec date, hFec date, xNumLin OUT NUMBER)
IS
BEGIN
    SELECT COUNT(*)INTO xNumLin
    FROM LINEASFACTURAS t1
    INNER JOIN FACTURAS t2 ON t1.nNumFac = t2.nNumFac
    INNER JOIN ARTICULOS t3 ON t1.cCodArt = t3.cCodArt
    WHERE t3.cCodFam = xcCodFam AND
    dFecFac BETWEEN dFec AND hFec;
END;

SET SERVEROUTPUT ON;
DECLARE
    res NUMBER;
BEGIN
    sp_LinFacxFan ('F1','01/01/2018','01/01/2018',res);
    DBMS_OUTPUT.PUT_LINE(res);
END;

--PROCEDIMIENTO CON DOS PARAMETROS DE ENTRADA : CODIGO DE FAMILIA Y % DE INCREMENTO.
--FUNCIONAMIENTO : DEBE INCREMENTAR EL PRECIO DE TODOS LOS ARTICULOS DE LA FAMILIA
--QUE SE DA COMO PARAMETRO DE ENTRADA EN UN % QUE SE DÁ COMO SEGUNDO PAR DE ENTRADA

CREATE OR REPLACE PROCEDURE sp_Incremento (xcCodFam FAMILIAS.cCodFam%TYPE, xIncremento NUMBER)
IS
BEGIN
    UPDATE ARTICULOS SET NPVPART = NPVPART + (NPVPART*INCREMENTO/100) WHERE CCODFAM=XCCODFAM;
END;

BEGIN
    p_Incremento('SE',5);
END;




--RECUERDO DE CURSORES
--PROCEDIMIENTO CON DOS PARAMETROS DE FECHAS DE ENTRADA Y QUE NOS HAGA UN 
--LISTADO CON EL CODIGO Y NOMBRE DEL CLIENTE Y CUANTAS FACTURAS HA RELIZADO
--EL CLIENTE ENTRE ESAS DOS FECHAS

CREATE OR REPLACE PROCEDURE
sp_numFacs(dFec DATE, hFec DATE)
IS   
    CURSOR cNum_Fac IS
        SELECT C.CCODCLI, C.CNOMCLI, COUNT(*) AS NUM_FACT
        FROM CLIENTES C INNER JOIN FACTURAS F ON C.CCODCLI = F.CCODCLI
        WHERE DFECFAC BETWEEN dFec AND hFec
        GROUP BY C.CCODCLI,CNOMCLI;
    xcNumFac cNum_Fac%ROWTYPE;
BEGIN
    OPEN cNum_Fac;
    LOOP
        FETCH cNum_Fac INTO xcNumFac;
        EXIT WHEN cNum_Fac%NOTFOUND; 
        DBMS_OUTPUT.PUT_LINE('El cliente ' || xcNumFac.cCodCli || ' Ha realizado ' || xcNumFac.NUM_FACT || ' Facturas entre esas fechas' );
    END LOOP;
END;

SELECT * FROM FACTURAS;

SET SERVEROUTPUT ON;
BEGIN
   sp_numFacs('01/03/17','05/05/17'); 
END;


--procedimiento con parametro de entrada numero de factura
--funcionamiento: imprimir la factura con todos sus datos cuyo numero es el del par. etrada

CREATE OR REPLACE PROCEDURE sp_ImprFac--(xNNUMFAC number, xCantidad NUMBER)
IS
    xTexto ARTICULOS%TYPE;
BEGIN 
   
 --CURSOR cDatosFactura IS
  
  SELECT 'FACTURA', 'FECHA', 'CLIENTE' INTO xTexto FROM DUAL;
    --SELECT F.NNUMFAC,F.DFECFAC,F.CCODCLI,C.CNOMCLI FROM FACTURAS F 
    --INNER JOIN CLIENTES C ON F.CCODCLI = C.CCODCLI WHERE F.NNUMFAC = xNNUMFAC;  
    --VARIABLE FACTURA%ROWTYPE; 
   -- OPEN cDatosFactura;
   -- LOOP
       -- FETCH cDatosFactura INTO VARIABLE;
      --  EXIT WHEN cDatosFactura%NOTFOUND;
        --DBMS_OUTPUT.PUT_LINE('HOLA');
   -- END LOOP;
    DBMS_OUTPUT.PUT_LINE( 'FACTURA ' || 'FECHA' || 'CLIENTE');
   
    --SELECT CCODART,CDESART,xCantidad,NPVPART,NDTOART,(xCantidad(NPVPART-NDTOART)) FROM ARTICULOS;
END;
-----------------------------------------
CREATE OR REPLACE PROCEDURE sp_ImprFac (xNNUMFAC FACTURAS.NNUMFAC%TYPE)
IS
    xRoxFac FACTURAS%ROWTYPE;
    xNomCli CLIENTES.CCODCLI%TYPE;
    CURSOR clin IS
        SELECT L.CCODART,CDESART,NCANART, NPVPART,NDTOLINFAC,
        (NCANART*NPVPART) - (NCANART*NPVPART*NDTOLINFACT/100) AS SUBTOTAL
        FROM LINFACTURAS L
        INNER JOIN ARTICULOS A ON L.CCODART=A.CCODART
        WHERE NNUMFAC = XNUMFAC;
    xclin CLIN%ROWTYPE;
    XTOTFAC NUMBER;
    
BEGIN
    --DATOS DE CABECERA FACTURAS
    SELECT * INTO XRoxFac FROM FACTURAS WHERE NNUMFAC=xNNUMFAC;
    DBMS_OUTPUT.PUT_LINE('FACTURA Nº ' || 'FECHA ' || xRoxFac.dFecFac || ' COD CLIENTE ' || xRoxFac.CCODCLI);
    --NOMBRE DE CLIENTE FACTURA
    SELECT cNOMCLI INTO XNOMCLI FROM CLIENTES C INNER JOIN FACTURAS F ON C.CCODCLI = F.CCODCLI WHERE NNUMFAC= XNUMFAC;
    --LINEAS DE FACTURA
    OPEN clin;
    LOOP
        FETCH clin INTO xclin;
        EXIT WHEN clin%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(xclin.CcodArt ||  xclin.CDESCArt || xclin.NCANTART || xclin.PVPART || xclin.SUBTOTAL);
        XTOTFACT := XTOTFACT + xclin.SUBTOTAL;

    END LOOP;
    
    CLOSE clin;

    
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('NO EXISTE LA FACTURA Nº ' || xNNUMFAC );
        WHEN TOO_MANY_ROWS THEN
        DBMS_OUTPUT.PUT_LINE('ERROR: DEMASIADOS REGISTROS DEVUELTOS');
END;

SET SERVEROUTPUT ON;
BEGIN
    sp_ImprFac(1001);


END;

------------------------------------------------------

--PROCEDIMIENTO QUE MUESTRE POR PANTALLA TODOS LOS CLIENTES Y POR CADA CLIENTE MUESTRE TODAS SUS FACTURAS
--cliente-01
--factura 1001 de fecha 110232

--ampliacion 1: de cada factura mostrar el totalde la factura;
--ampliacion 2: de cada cliente mostrar al final cuantasfacturas tiene
--ampliacion 3: el procedimiento tiene dos parametros de entrada que son los intervalos de fechas de facturas
--ampliacion 4; el proce. devuelve un parametro de salida con la sumatoria total de todas las facturas


CREATE OR REPLACE PROCEDURE sp_Clientes
IS 
    CURSOR cClie IS 
        SELECT CCODCLI FROM CLIENTES;
        xClie cClie%ROWTYPE;
    
BEGIN
    OPEN cClie;
    LOOP
        FETCH cClie INTO xClie;
        EXIT WHEN cClie%NOTFOUND;
        DBMS_OUTPUT.PUT_LINE(xClie.CCODCLI);
       
    END LOOP;    
    CLOSE cClie;
    

--2 CURSOR CON LOS CLIENTES
--3 CURSOR QUE POR CADA CLIENTE MUESTRE LA FACTURA (PARAMETRIZADO)
END;

SET SERVEROUTPUT ON;
BEGIN
    sp_Clientes;  

END;
SELECT * FROM CLIENTES;


--TRIGGERS

CREATE TABLE mensajes(mensaje VARCHAR2(100), fecha DATE);

CREATE OR REPLACE TRIGGER tr_ARTICULOS_Ins
BEFORE INSERT
ON ARTICULOS
BEGIN
    INSERT INTO mensajes VALUES ('Alguien inserta articulos', SYSDATE);
END;

SELECT * FROM MENSAJES;
INSERT INTO ARTICULOS VALUES ('SE99','SE','SEVILLA',250,12,1,25);
SELECT * FROM ARTICULOS;
--A NIVEL DE ORDEN SOLO SE CREA UN TRIGGER EN LA INSERCION
CREATE TABLE ART2 AS
    SELECT * FROM ARTICULOS;
SELECT * FROM ART2;

INSERT INTO ARTICULOS
    SELECT * FROM ART2;
    
--A NIVEL DE REGISTRO
CREATE OR REPLACE TRIGGER tr_ARTICULOS_Ins2
BEFORE INSERT
ON ARTICULOS
FOR EACH ROW
BEGIN
    INSERT INTO mensajes VALUES ('Alguien ha insertado un registro', SYSDATE);
END;    


--A NIVEL DE REGISTRO
CREATE OR REPLACE TRIGGER tr_ARTICULOS_Ins3
BEFORE INSERT
ON ARTICULOS
FOR EACH ROW
BEGIN
    INSERT INTO mensajes VALUES (USER || 'Ha insertado el registro....' || :NEW.CCODART, SYSDATE);
END;  


INSERT INTO ARTICULOS
    SELECT * FROM ART2;

  SELECT * FROM MENSAJES;  
  
SELECT * FROM LINEASFACTURAS;

CREATE OR REPLACE TRIGGER tr_LINEASFACTURAS_Ins
AFTER
INSERT
ON LINEASFACTURAS
FOR EACH ROW
DECLARE
    xPrecio ARTICULOS.NPVPART%TYPE;
BEGIN
    SELECT NPVPART INTO xPrecio FROM ARTICULOS WHERE CCODART = :NEW.CCODART;
    UPDATE ARTICULOS SET NSTOCKART = NSTOCKART - :new.NCANARTC WHERE cCodArt = :new.cCodArt;
    UPDATE FACTURAS SET NBASEIMO = NBASEIMO + (xPrecio * :NEW.NCANARTC) WHERE NNUMFAC = :NEW.NNUMFAC; 
END;

select * from facturas;
select * from articulos;
INSERT INTO LINEASFACTURAS VALUES (4,2,'X2',1,0)
xPrecio



INSERT INTO LINEASFACTURAS(NNUMFAC, NNUMLIN, CCODART, NCANARTC, NDTOLINFAC) VALUES (4,6,'SE02',2,-1);
 SELECT * FROM ARTICULOS;  
SELECT * FROM LINEASFACTURAS;

ALTER TABLE LINEASFACTURAS ADD CONSTRAINT CK_LF_1 CHECK (NDTOLINFAC >=0);

CREATE OR REPLACE TRIGGER tr_ARTICULOS_Del
BEFORE 
DELETE
ON ARTICULOS 
FOR EACH ROW
BEGIN
    DELETE FROM LINEASFACTURAS WHERE CCODART = :old.CCODART;
END;


CREATE OR REPLACE TRIGGER tr_LINEASFACTURAS_Upd_6
AFTER UPDATE 
ON LINEASFACTURAS 
FOR EACH ROW
BEGIN
    UPDATE ARTICULOS SET NSTOCKART = NSTOCKART + :OLD.NCANARTC WHERE cCodArt = :OLD.cCodArt;
    UPDATE ARTICULOS SET NSTOCKART = NSTOCKART - :NEW.NCANARTC WHERE cCodArt = :NEW.cCodArt;
END;

CREATE OR REPLACE TRIGGER tr_LINEASFACTURAS_dEL_6
AFTER DELETE
ON LINEASFACTURAS 
FOR EACH ROW
BEGIN
    UPDATE ARTICULOS SET NSTOCKART = NSTOCKART + :OLD.NCANARTC WHERE cCodArt = :OLD.cCodArt;
END;

CREATE OR REPLACE TRIGGER tr_LINEASFACTURAS_Upd_7
AFTER UPDATE 
ON LINEASFACTURAS 
FOR EACH ROW
BEGIN
    UPDATE ARTICULOS SET NSTOCKART = NSTOCKART + :OLD.NCANARTC WHERE cCodArt = :OLD.cCodArt;
    UPDATE ARTICULOS SET NSTOCKART = NSTOCKART - :NEW.NCANARTC WHERE cCodArt = :NEW.cCodArt;
END;






SELECT * FROM ARTICULOS;
SELECT * FROM LINEASFACTURAS;
DELETE FROM ARTICULOS WHERE CCODART = 'SE02'
SELECT TIPO FROM MOVCUENTAS WHERE 'I' LIKE 'I' 

CREATE TABLE CUENTAS (
    CC VARCHAR2(20),
    SALDO NUMBER(12,2));
    
CREATE TABLE MOVCUENTAS (
    TIPO VARCHAR2(1), --TIPO DE MOVIMIENTO
    CC_ORIGEN VARCHAR2(20), --EXISTIR
    CC_DESTINO VARCHAR2(20), --EXISTIR
    IMPORTE NUMBER(12,2));  --MENOR QUE SALDO
    
ALTER TABLE MOVCUENTAS ADD CONSTRAINT CK_MOVCUENTAS_TIPO CHECK ( TIPO IN ('T', 'I', 'R'));
INSERT INTO MOVCUENTAS (TIPO, CC_ORIGEN,IMPORTE) VALUES ('I','B1',-18000);



SELECT * FROM CUENTAS
INSERT INTO CUENTAS VALUES ('B1',1000);
INSERT INTO CUENTAS VALUES ('B2',1500);
INSERT INTO CUENTAS VALUES ('B3',5500);
INSERT INTO CUENTAS VALUES ('B4',8550);
SELECT COUNT(*) FROM CUENTAS WHERE CC = 'B1' AND SALDO>:1000;
SELECT COUNT(*) FROM MOVCUENTAS WHERE TIPO NOT LIKE 'I';
SELECT * FROM MOVCUENTAS



CREATE OR REPLACE TRIGGER tr_MOVCUENTAS_Ins
BEFORE INSERT
ON MOVCUENTAS
FOR EACH ROW
DECLARE
    x NUMBER;
    z NUMBER;
    xTipo MOVCUENTA.TIPO%TYPE;
BEGIN
 
    SELECT COUNT(*) INTO x FROM CUENTAS WHERE CC = :NEW.CC_ORIGEN;
    --INGRESOS
    IF (:NEW.TIPO = 'I' AND NRO= 1 ) THEN
     UPDATE CUENTAS SET SALDO = SALDO + :NEW.IMPORTE WHERE CC = :NEW.CC_ORIGEN;
    --SELECT COUNT(*) INTO z FROM CUENTAS WHERE CC = :NEW.CC_DESTINO;
    SELECT COUNT(*) INTO s FROM CUENTAS WHERE CC = :NEW.CC_ORIGEN AND SALDO<:NEW.IMPORTE;
    
    IF x <=0 THEN       
        raise_application_error( -20501,'La cuenta ' || :NEW.CC_ORIGEN || ' no existe' );
    END IF;
    --IF Z <=0 THEN      
        --raise_application_error( -20501,'La cuenta ' || :NEW.CC_DESTINO || ' no existe' );
   -- END IF;
    IF s <= 0 THEN
        raise_application_error( -20501,'La cuenta ' || :NEW.CC_ORIGEN || ' está negativa' );
    END IF;
    --IF SELECT TIPO FROM MOVCUENTAS WHERE :NEW.TIPO NOT LIKE 'I' THEN 
        --raise_application_error( -20501,'La operación ' || :NEW.TIPO || ' que quiere realizar no existe I para insertar' );
    --END IF;
    UPDATE CUENTAS SET SALDO = SALDO + :NEW.IMPORTE WHERE CC = :NEW.CC_ORIGEN;
END;


--TRANSFERENCIA
--INGRESO
--REINTEGRO

--CADA VEZ QUE SE INSERTE, BORRE O MODIFIQUE LOSCAMPOS TIPO O IMPORTE DE LA TABLA 
--MOVCUENTAS SE DISPARARÁ UN TRIGGER QUE ACTUALIZARÁ LA TABLA CUENTAS
--COMPROBAD QUE LAS CUENTAS DEBEN DE EXISTIR

CREATE TRIGGER tr_MOVCUENTAS_Ins
AFTER
INSERT
ON MOVCUENTAS
FOR EACH ROW
DECLARE
    NRO NUMBER(10);
    NRD NUMBER(10);
    SELECT COUNT
BEGIN
END;

--DOS CUENTAS CORRIENTES DIFERENTES
UPDATE FAMILIAS SET CDESFAM = 'SS' WHERE CDESFAM = 'ERERER' ;
select * from familias
SELECT * FROM FAMILIAS WHERE cCodFam = 'SE'
SELECT * FROM FAMILIAS WHERE cCodFam = S1
INSERT INTO CLIENTES VALUES('ad','descsd')
DELETE CLIENTES WHERE cCodCli = 'SS'
DELETE FAMILIAS WHERE cCodCli = 'ddd'
DELETE FAMILIAS WHERE CCODFAM = 'ddd'
SELECT * FROM FAMILIAS
UPDATE FAMILIAS SET cCodFam ='DSS' WHERE cDesFam = 'SS'
UPDATE FAMILIAS SET cCodFam ='DSSS' WHERE cDesFam = 'SS'

CREATE OR REPLACE TRIGGER tr_MOVCUENTAS_Ins
BEFORE INSERT
ON MOVCUENTAS
FOR EACH ROW
DECLARE
    NRO NUMBER;
    NRD NUMBER;
    xTipo MOVCUENTAS.TIPO%TYPE;
    xSaldo CUENTAS.SALDO%TYPE;
BEGIN 
    SELECT COUNT(*) INTO NRO FROM CUENTAS WHERE CC = :NEW.CC_ORIGEN;
    --INGRESOS
    IF (:NEW.TIPO = 'I' AND NRO= 1 ) THEN
        UPDATE CUENTAS SET SALDO = SALDO + :NEW.IMPORTE WHERE CC = :NEW.CC_ORIGEN;    
    END IF;
    IF (:NEW.TIPO = 'I' AND NRO =1) THEN
        raise_application_error( -20501,'La cuenta ' || :NEW.CC_ORIGEN || ' no existe' );
    END IF;
    --REINTEGRO
    IF (:NEW.TIPO = 'R' AND NRO= 1 ) THEN
        SELECT SALDO INTO xSaldo FROM CUENTAS WHERE cc = :NEW.CC_ORIGEN;
    IF (XSALDO < :NEW.IMPORTE) THEN
        raise_application_error( -20501,'La cuenta ' || :NEW.CC_ORIGEN || ' no existe' );
    END IF;
    UPDATE CUENTAS SET SALDO = SALDO - :NEW.IMPORTE WHERE CC = :NEW.CC_ORIGEN;
    END IF;
    IF (:NEW.TIPO = 'I' AND NRO =1) THEN
        raise_application_error( -20501,'La cuenta ' || :NEW.CC_ORIGEN || ' no existe' );
    END IF;
    --TRANSFERENCIA
    IF (:NEW.TIPO = 'T' AND NRO = 1 ) THEN
    SELECT SALDO INTO xSaldo FROM CUENTAS WHERE cc = :NEW.CC_ORIGEN; 
    END IF;
    IF (XSALDO < :NEW.IMPORTE ) THEN
        raise_application_error( -20501,'SALDO INSUFICIENTE ' );
    END IF;    
        SELECT COUNT(*) INTO NRD FROM CUENTAS WHERE CC = :NEW.CC_DESTINO;
    IF (NRD !=1) THEN
        raise_application_error( -20501,'La cuenta DESTINO DE LA TRANSFERENCIA no existe' );
    END IF;
    UPDATE CUENTAS SET SALDO = SALDO - :NEW.IMPORTE WHERE CC = :NEW.CC_ORIGEN;
    UPDATE CUENTAS SET SALDO = SALDO + :NEW.IMPORTE WHERE CC = :NEW.CC_DESTINO;
    IF (:NEW.TIPO = 'T' AND NRO != 1 ) THEN
        raise_application_error( -20501,'ERROR EN NUMERO DE CUENTA ORIGEN' );
    END IF;
END;

--PARA BORRAR

CREATE OR REPLACE TRIGGER tr_MOVCUENTAS_Del
AFTER DELETE
ON MOVCUENTAS
FOR EACH ROW
DECLARE
    NRO NUMBER;
    NRD NUMBER;
    xTipo MOVCUENTAS.TIPO%TYPE;
    xSaldo CUENTAS.SALDO%TYPE;
BEGIN 
    SELECT COUNT(*) INTO NRO FROM CUENTAS WHERE CC = :OLD.CC_ORIGEN;
    --INGRESOS
    IF (:OLD.TIPO = 'I' AND NRO= 1 ) THEN
        UPDATE CUENTAS SET SALDO = SALDO - :NEW.IMPORTE WHERE CC = :OLD.CC_ORIGEN;    
    END IF;
    IF (:OLD.TIPO = 'I' AND NRO =1) THEN
        raise_application_error( -20501,'La cuenta ' || :OLD.CC_ORIGEN || ' no existe' );
    END IF;
    --REINTEGRO
    IF (:OLD.TIPO = 'R' AND NRO= 1 ) THEN
        SELECT SALDO INTO xSaldo FROM CUENTAS WHERE cc = :OLD.CC_ORIGEN;
    IF (XSALDO < :NEW.IMPORTE) THEN
        raise_application_error( -20501,'La cuenta ' || :OLD.CC_ORIGEN || ' no existe' );
    END IF;
    UPDATE CUENTAS SET SALDO = SALDO + :OLD.IMPORTE WHERE CC = :OLD.CC_ORIGEN;
    END IF;
    IF (:OLD.TIPO = 'I' AND NRO =1) THEN
        raise_application_error( -20501,'La cuenta ' || :OLD.CC_ORIGEN || ' no existe' );
    END IF;
    --TRANSFERENCIA
    IF (:OLD.TIPO = 'T' AND NRO = 1 ) THEN
    SELECT SALDO INTO xSaldo FROM CUENTAS WHERE cc = :OLD.CC_DESTINO; 
    END IF;
    IF (XSALDO < :OLD.IMPORTE ) THEN
        raise_application_error( -20501,'SALDO INSUFICIENTE ' );
    END IF;    
        SELECT COUNT(*) INTO NRD FROM CUENTAS WHERE CC = :OLD.CC_DESTINO;
    IF (NRD !=1) THEN
        raise_application_error( -20501,'La cuenta DESTINO DE LA TRANSFERENCIA no existe' );
    END IF;
    UPDATE CUENTAS SET SALDO = SALDO + :OLD.IMPORTE WHERE CC = :OLD.CC_ORIGEN;
    UPDATE CUENTAS SET SALDO = SALDO - :OLD.IMPORTE WHERE CC = :OLD.CC_DESTINO;
    IF (:OLD.TIPO = 'T' AND NRO != 1 ) THEN
        raise_application_error( -20501,'ERROR EN NUMERO DE CUENTA ORIGEN' );
    END IF;
END;

SELECT * FROM MOVCUENTAS WHERE TIPO = 'I' AND IMPORTE = 200 AND CC_ORIGEN = '123';
DELETE MOVCUENTAS WHERE TIPO = 'I' AND IMPORTE = 200 AND CC_ORIGEN = '123';
